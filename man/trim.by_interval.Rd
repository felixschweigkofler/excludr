% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trimming.R
\name{trim.by_interval}
\alias{trim.by_interval}
\title{Trim the lowest and/or highest values in groupings of an ldf}
\usage{
trim.by_interval(
  ldf,
  group.by,
  apply.to = NULL,
  apply.not.to = NULL,
  trim = 0.025,
  trim.ties = T,
  warn.ties = T,
  view.ties = F,
  ignore.na = T,
  report.by = NULL,
  return.report = F,
  notify = T,
  value.col = "value"
)
}
\arguments{
\item{ldf}{A long format dataframe with one column holding the values and at least one column holding identifiers that can be used to group the values. Compare example.trial.data().}

\item{group.by}{Identifier-columns that are used to create groupings, to which the test is applied.}

\item{apply.to, apply.not.to}{A named list of vectors to (un)select rows. The names of the columns are specified by the element names, and the identifiers in this column to which the trimming should (not) be applied are specified by the vector. Default to NULL, which means no (un)selection is applied to any column.}

\item{trim}{Proportion or number of values in a grouping that should be trimmed from bottom and top. Values < 1 are interpreted as proportion of observations, values >= 1 as number of observations. If only one value is provided, it will be used for bottom and top. Defaults to c(0.025,0.025), i.e. 95&#37; interval}

\item{trim.ties}{Tied values around the edge of the trim-cutoff defined by 'trim' are trimmed together, even when doing so increases the share of trimmed values beyond the specification of trim. If FALSE, tied values to be trimmed are sampled, which can lead to unexpected behaviour when the ties around the bot-cutoff and the top-cutoff are the same (e.g. when a grouping has only a single unique value). Defaults to TRUE.}

\item{warn.ties}{Issues a warning when there are ties in any grouping defined by 'group.by'. Defaults to TRUE.}

\item{view.ties}{Returns a dataframe with descriptions of the ties instead of the trimmed ldf. Defaults to FALSE.}

\item{ignore.na}{Ignores NA-values when calculating the number of values to be trimmed from the trim-proportion and the size of the grouping. Defaults to TRUE.}

\item{report.by}{Identifier-columns that are used to create groupings, for which statistics are printed when notify is TRUE. Defaults to NULL, which means one value for the entire ldf is returned.}

\item{return.report}{Adds the trimming report to the trimmed ldf in a list. Defaults to FALSE.}

\item{notify}{Provides progress information. Defaults to TRUE.}

\item{value.col}{Name of the column holding the values in the ldf. Defaults to 'value'.}
}
\description{
Groups an ldf by certain columns and finds the x highest and or lowest values in each grouping, to overwrite them with NA. Tied values can be trimmed together or randomly.
}
\examples{
# Trim the bottom and top 0.1 RT values for each participant in each session separately
ldf = trim.by_interval(ldf = example.trial.data(), group.by = c('ID', 'session', 'measure'), apply.to = list(measure = 'RT'), trim = 0.1)
# Do the same again using the already trimmed ldf. Note that no values were trimmed and a warning was issued: ldf now only has 8 non-NA values per grouping and since NAs are ignored per default, trim = 0.1 results in a requirement to trim 0.8 values, which is rounded down to 0.
ldf2 = trim.by_interval(ldf = ldf, group.by = c('ID', 'session'), apply.to = list(measure = 'RT'), trim = 0.1)
# When ignore.na = FALSE or the proportion to be trimmed is higher, this does not happen
ldf2 = trim.by_interval(ldf = ldf, group.by = c('ID', 'session'), apply.to = list(measure = 'RT'), trim = 0.1, ignore.na = F)
ldf2 = trim.by_interval(ldf = ldf, group.by = c('ID', 'session'), apply.to = list(measure = 'RT'), trim = 0.13)
# Trim the four highest RT values, when additionally grouping by 'condition' and excluding participant 1 and 2.
ldf = trim.by_interval(ldf = example.trial.data(), group.by = c('ID', 'session', 'measure'), apply.to = list(measure = 'RT'), apply.not.to = list(ID = 1:2), trim = c(0,4))
# Trim the highest and lowest observation and report the trimming for each measure: All ACC-values are trimmed, because it only contains the values 0 and 1, and since trim.ties = T is default, all 0s and 1s are trimmed when 0 and 1 are the highest and lowest value.
ldf = trim.by_interval(ldf = example.trial.data(), group.by = c('ID', 'session', 'measure'), report.by = 'measure', trim = 1)
# Set 'trim.ties' to FALSE to avoid this behavior and trim strictly the amount of values defined by 'trim'. Values to be trimmed are sampled randomly from the pool of relevant tied values. If the tied value affecting the upper and lower threshold is the same (as can be the case here for ACC, with all 1s), it can happen that the mechanism for the upper and lower threshold sample the same row and thus fewer values than required by 'trim' are trimmed.
ldf = trim.by_interval(ldf = example.trial.data(), group.by = c('condition','ID', 'session','measure'), report.by = 'measure', trim = 1, trim.ties = F)
}
\keyword{trimming}
