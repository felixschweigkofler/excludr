% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trimming.R
\name{exclude.groupings}
\alias{exclude.groupings}
\title{Exclude groupings of an ldf, if they fulfil a certain criterion}
\usage{
exclude.groupings(
  ldf,
  group.by,
  exclude.by = NULL,
  test = NULL,
  test.not = NULL,
  excl = NULL,
  excl.not = NULL,
  stat.func = "mean",
  criterion = function(S) return(S <= 0.5),
  value.col = "value",
  report.by = NULL,
  return.report = F,
  return.stats = F,
  notify = T
)
}
\arguments{
\item{ldf}{A long format dataframe with one column (assumed name: 'value') holding the values and at least one column holding identifiers that can be used to group the values. See example.trial.data() for a correctly formatted long dataframe.}

\item{group.by}{Identifier-columns that are used to create groupings, to which the test is applied.}

\item{exclude.by}{Identifier-columns that are used to group the data for exclusion. Can not contain names that are not in 'group.by' (i.e. can not be more specific). Defaults to NULL, which means names will be copied from group.by}

\item{stat.func}{Name of a function that can take a vector and output a scalar. This function is used to summarise the values of each grouping. Defaults to 'mean'. 'na.rm = T' is passed as additional argument.}

\item{criterion}{Function that defines in which cases an output of the 'stat.func' fulfills the exclusion criterion. Defaults to 'function(stat) return(stat <= -.5)', i.e. exclusion-worthy are groupings whose summary value is smaller than 0.5 The function must use the arg 'stat', which is a scalar.}

\item{value.col}{Name of the column holding the values in the ldf. Defaults to 'value'.}

\item{return.stats}{Returns the ldf and trimming statistics in a list. FALSE returns just the ldf. Defaults to FALSE.}

\item{notify}{Provides progress information. Defaults to TRUE.}

\item{apply.to, apply.not.to}{A named list of vectors to (un)select rows. The names of the columns are specified by the element names, and the identifiers in this column to which the trimming should (not) be applied are specified by the vector. Default to NULL, which means no (un)selection is applied to any column.}

\item{return.format}{'ldf' for long dataframe (as provided) or 'wdf' for wider dataframe, where the values of each measure are put in a separate column. Defaults to 'ldf'.}
}
\description{
Groups an ldf by certain columns, calculates a freely definable statistic for each grouping, compares the result against a certain threshold, and trims all values in each grouping that crosses the threshold by overwriting them with NA
}
\examples{
# Exclude each participant in each session who has a mean ACC smaller or equal 0.8. 'exclude.by' is not defined, therefore a grouping's test is only applied to itself. 'excl' is not defined, therefore RT values are excluded as well, not only the ACC-values which were tested
ldf = exclude.groupings(ldf = example.trial.data(), group.by = c('ID','session'), test = list(measure = 'ACC'), criterion = function(S) return(S <= 0.8))
# Do the same, but now make the exclusion-grouping less fine-grained than the test-grouping: By setting exclude.by = 'ID', a participant's values are excluded in both sessions, if the participant fulfils the exclusion criteria in either or both sessions (a test of the 'ID*session'-sub-grouping is projected to the exclusion-super-grouping 'ID')
ldf = exclude.groupings(ldf = example.trial.data(), group.by = c('ID','session'), exclude.by = c('ID'), test = list(measure = 'ACC'), criterion = function(S) return(S <= 0.8))
# Do the same, but now exempt session 2 from exclusion. Note that it is not exempt from testing, which means a participant who fulfils the criterion in session 2 is excluded in session 1, but session 2 is exempt
ldf = exclude.groupings(ldf = example.trial.data(), group.by = c('ID','session'), exclude.by = c('ID'), test = list(measure = 'ACC'), excl.not = c(session = '2'), criterion = function(S) return(S <= 0.8))
# Back to the basic exclusion, but while testing ACC, only apply exclusion to RT. 'report.by' won't show
ldf = exclude.groupings(ldf = example.trial.data(), group.by = c('ID','session'), test = list(measure = 'ACC'), excl = list(measure = 'RT'), criterion = function(S) return(S <= 0.8), report.by = c('measure','session'))
stat = trim.statistics(ldf = ldf, report.by = c('measure','session'), print.stats = T)
# Exclude participants entire ACC data, if their median RT in condition A was higher than 1000 or lower than 400
ldf = exclude.groupings(ldf = example.trial.data(), group.by = c('ID','session','condition'), exclude.by = 'ID', test = list(measure = 'RT', condition = 'A'), excl = list(measure = 'ACC'), stat.func = 'median', criterion = function(S) return(S < 400 | S > 1000), report.by = 'measure')
}
\keyword{exclusion}
